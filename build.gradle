import com.mkobit.jenkins.pipelines.http.ApiTokenAuthentication
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

buildscript {
  repositories {
    mavenCentral() // must be first to resolve eddsa!
    maven {
      url "https://repo.jenkins-ci.org/public/"
    }
    maven {
      url "https://repo.jenkins-ci.org/releases/"
    }
    maven {
      url "https://maven.google.com"
    }
    gradlePluginPortal()
  }
  dependencies {
    classpath("org.antlr:antlr4-runtime:4.13.2")
    classpath("com.squareup.okhttp3:okhttp:4.9.3")
    classpath("com.google:google:5")
    classpath("com.google.inject:guice:6.0.0")
    classpath("org.eclipse.ee4j:project:1.0.6")
    classpath("jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:2.0.0")
    classpath("com.google.guava:failureaccess:1.0.2")
    classpath("org.springframework.security:spring-security-web:6.4.2")
  }
}

plugins {
  id 'com.mkobit.jenkins.pipelines.shared-library' version '0.10.1'
  id 'java'
  id 'groovy'
}

repositories.removeIf { it.name == "JenkinsPublic" }

repositories {
  mavenCentral()
  maven {
    url "https://repo.jenkins-ci.org/public/"
  }
  maven {
    url "https://repo.jenkins-ci.org/releases/"
  }
  maven {
    url "https://maven.google.com"
  }
  gradlePluginPortal()
}

tasks {
  wrapper {
    gradleVersion = '8.12'
  }
}

java {
  sourceCompatibility = JavaVersion.VERSION_17
}

dependencies {
  testImplementation(platform("org.junit:junit-bom:${junitVersion}"))
  testImplementation('org.junit.jupiter:junit-jupiter')
  testImplementation("org.mockito:mockito-junit-jupiter:${mockitoVersion}")
}

test {
  useJUnitPlatform()
}

def jenkinsResourcesFolder = 'jenkinsResources'
def pipelinesFolder = 'pipelines'
def allSrcDirs = [pipelinesFolder, jenkinsResourcesFolder, 'vars', 'src']

sourceSets {
  main {
    java {
      srcDirs = [allSrcDirs]
      exclude 'resources'
    }
  }
  integrationTest {
    java {
      srcDirs = [allSrcDirs]
      exclude 'resources'
    }
  }
}

if (project.hasProperty("jenkinsUrl") && project.hasProperty("jenkinsUser") && project.hasProperty("jenkinsApiToken")) {
  jenkinsIntegration {
    baseUrl.set(uri(project.property("jenkinsUrl")).toURL())
    authentication.set(providers.provider { new ApiTokenAuthentication(project.property("jenkinsUser").toString(), project.property("jenkinsApiToken").toString()) })
    downloadDirectory.set(layout.projectDirectory.dir(jenkinsResourcesFolder))
  }
}

def coreVersionFile = project.file("${jenkinsResourcesFolder}/core-version.txt")
if (coreVersionFile.exists()) {
  def jenkinsVersion = coreVersionFile.text.trim()
  sharedLibrary {
    coreVersion = jenkinsVersion
  }
}

def dependenciesFile = file("${jenkinsResourcesFolder}/dependencies.json")
if (dependenciesFile.exists()) {
  def contents = new JsonSlurper().parse(dependenciesFile)
  sharedLibrary {
    pluginDependencies {
      contents.dependencies.each { dep ->
        dependency(dep.group, dep.name, dep.version)
      }
    }
  }
}

tasks.register('syncJenkinsConfig') {}

tasks.register('collectPluginDependencies') {
  doLast {
    def excludedPlugins = [] as Set
    def pluginsFile = file("${jenkinsResourcesFolder}/plugins.json")
    def dependencies = []
    def notResolvedPlugins = []

    if (pluginsFile.exists()) {
      def contents = new JsonSlurper().parse(pluginsFile)

      contents.plugins.each { plugin ->
        if (excludedPlugins.contains(plugin.shortName)) {
          logger.lifecycle("Plugin '${plugin.shortName}' is skipped")
        } else if (plugin.active && plugin.enabled) {
          try {
            def pluginInfoUrl = new URL("https://plugins.jenkins.io/api/plugin/${plugin.shortName}")
            def connection = pluginInfoUrl.openConnection()
            connection.setRequestProperty("User-Agent", "Gradle")

            def pluginInfo = new JsonSlurper().parse(connection.inputStream)
            def groupId = pluginInfo?.gav?.split(":")?.getAt(0)

            if (groupId) {
              def dependency = resolveDependency(groupId, plugin.shortName, plugin.version)
              if (dependency) {
                dependencies.add([group: groupId, name: plugin.shortName, version: plugin.version])
                logger.lifecycle("Dependency '${dependency}' resolved")
              } else {
                notResolvedPlugins.add(plugin.shortName)
                logger.warn("Failed to resolve dependency for '${plugin.shortName}'")
              }
            } else {
              notResolvedPlugins.add(plugin.shortName)
              logger.warn("GroupId not found for plugin '${plugin.shortName}'")
            }
          } catch (Exception e) {
            notResolvedPlugins.add(plugin.shortName)
            logger.warn("Failed to fetch metadata for plugin '${plugin.shortName}': ${e.message}")
          }
        } else {
          logger.lifecycle("Plugin '${plugin.shortName}' is disabled")
        }
      }

      logger.lifecycle("Not resolved plugins: ${notResolvedPlugins.join(', ')}")

      def output = file("${jenkinsResourcesFolder}/dependencies.json")
      if (output.exists()) output.delete()
      output.createNewFile()

      output << JsonOutput.prettyPrint(JsonOutput.toJson([dependencies: dependencies]))
    } else {
      logger.warn("Plugins file '${pluginsFile}' does not exist.")
    }
  }
}

tasks.named('syncJenkinsConfig') {
  dependsOn retrieveJenkinsVersion, retrieveJenkinsGdsl, collectPluginDependencies
}

def resolveDependency(String group, String shortName, String version) {
  try {
    def dependency = "${group}:${shortName}:${version}"
    def testConfig = project.configurations.create("testConfig-${UUID.randomUUID()}")
    testConfig.setCanBeResolved(true)
    project.dependencies."${testConfig.name}" dependency
    testConfig.resolve()
    return dependency
  } catch (ignored) {
    return null
  }
}
