import com.mkobit.jenkins.pipelines.http.ApiTokenAuthentication
import groovy.json.JsonOutput
import groovy.json.JsonSlurper

plugins {
  id 'com.mkobit.jenkins.pipelines.shared-library' version '0.10.1'
  id 'java'
  id 'groovy'
}

tasks {
  wrapper {
    gradleVersion = '8.12'
  }
}

java {
  sourceCompatibility = JavaVersion.VERSION_17
}

repositories.removeIf { it.name == "JenkinsPublic" }

repositories {
  mavenCentral()
  google()
  gradlePluginPortal()

  maven { url = uri("https://repo.jenkins-ci.org/public/") }
  maven { url = uri("https://repo.jenkins-ci.org/releases/") }
  maven { url = uri("https://repo.jenkins-ci.org/snapshots/") }
  maven { url = uri("https://repo.jenkins-ci.org/incrementals/") }
}

dependencies {
  implementation platform("org.jenkins-ci.plugins:plugin:4.66")
  compileOnly "com.github.ben-manes.caffeine:caffeine:3.2.0"
  compileOnly "org.springframework.security:spring-security-web:6.4.2"
  compileOnly "org.jenkins-ci.plugins:gradle:2.14.1"
  testImplementation(platform("org.junit:junit-bom:${junitVersion}"))
  testImplementation('org.junit.jupiter:junit-jupiter')
  testImplementation("org.mockito:mockito-junit-jupiter:${mockitoVersion}")
}

test {
  useJUnitPlatform()
}

def jenkinsResourcesFolder = 'jenkinsResources'
def pipelinesFolder = 'pipelines'
def allSrcDirs = [pipelinesFolder, jenkinsResourcesFolder, 'vars', 'src']

sourceSets {
  main {
    java {
      srcDirs = [allSrcDirs]
      exclude 'resources'
    }
  }
  integrationTest {
    java {
      srcDirs = [allSrcDirs]
      exclude 'resources'
    }
  }
}

if (project.hasProperty("jenkinsUrl") && project.hasProperty("jenkinsUser") && project.hasProperty("jenkinsApiToken")) {
  jenkinsIntegration {
    baseUrl.set(uri(project.property("jenkinsUrl")).toURL())
    authentication.set(providers.provider { new ApiTokenAuthentication(project.property("jenkinsUser").toString(), project.property("jenkinsApiToken").toString()) })
    downloadDirectory.set(layout.projectDirectory.dir(jenkinsResourcesFolder))
  }
}

def coreVersionFile = project.file("${jenkinsResourcesFolder}/core-version.txt")
if (coreVersionFile.exists()) {
  def jenkinsVersion = coreVersionFile.text.trim()
  sharedLibrary {
    coreVersion = jenkinsVersion
  }
}

def dependenciesFile = file("${jenkinsResourcesFolder}/dependencies.json")
if (dependenciesFile.exists()) {
  def contents = new JsonSlurper().parse(dependenciesFile)
  contents.dependencies.each { dep ->
    sharedLibrary {
      pluginDependencies {
        dependency(dep.group, dep.name, dep.version)
      }
    }
  }
}

tasks.register('syncJenkinsConfig') {}

tasks.register('collectPluginDependencies') {
  doLast {
    def excludedPlugins = [] as Set
    def pluginsFile = file("${jenkinsResourcesFolder}/plugins.json")
    def dependencies = []
    def notResolvedPlugins = []

    if (pluginsFile.exists()) {
      def contents = new JsonSlurper().parse(pluginsFile)

      contents.plugins.each { plugin ->
        if (excludedPlugins.contains(plugin.shortName)) {
          logger.lifecycle("Plugin '${plugin.shortName}' is skipped")
        } else if (plugin.active && plugin.enabled) {
          try {
            def pluginInfoUrl = new URL("https://plugins.jenkins.io/api/plugin/${plugin.shortName}")
            def connection = pluginInfoUrl.openConnection()
            connection.setRequestProperty("User-Agent", "Gradle")

            def pluginInfo = new JsonSlurper().parse(connection.inputStream)
            def groupId = pluginInfo?.gav?.split(":")?.getAt(0)

            if (groupId) {
              def dependency = resolveDependency(groupId, plugin.shortName, plugin.version)
              if (dependency) {
                dependencies.add([group: groupId, name: plugin.shortName, version: plugin.version])
                logger.lifecycle("Dependency '${dependency}' resolved")
              } else {
                notResolvedPlugins.add(plugin.shortName)
                logger.warn("Failed to resolve dependency for '${plugin.shortName}'")
              }
            } else {
              notResolvedPlugins.add(plugin.shortName)
              logger.warn("GroupId not found for plugin '${plugin.shortName}'")
            }
          } catch (Exception e) {
            notResolvedPlugins.add(plugin.shortName)
            logger.warn("Failed to fetch metadata for plugin '${plugin.shortName}': ${e.message}")
          }
        } else {
          logger.lifecycle("Plugin '${plugin.shortName}' is disabled")
        }
      }

      logger.lifecycle("Not resolved plugins: ${notResolvedPlugins.join(', ')}")

      def output = file("${jenkinsResourcesFolder}/dependencies.json")
      if (output.exists()) output.delete()
      output.createNewFile()

      output << JsonOutput.prettyPrint(JsonOutput.toJson([dependencies: dependencies]))
    } else {
      logger.warn("Plugins file '${pluginsFile}' does not exist.")
    }
  }
}

tasks.named('syncJenkinsConfig') {
  dependsOn retrieveJenkinsVersion, retrieveJenkinsGdsl, collectPluginDependencies
}

def resolveDependency(String group, String shortName, String version) {
  try {
    def dependency = "${group}:${shortName}:${version}"
    def testConfig = project.configurations.create("testConfig-${UUID.randomUUID()}")
    testConfig.setCanBeResolved(true)
    project.dependencies."${testConfig.name}" dependency
    testConfig.resolve()
    return dependency
  } catch (ignored) {
    return null
  }
}
