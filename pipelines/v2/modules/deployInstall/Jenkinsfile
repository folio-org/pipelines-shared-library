package v2.modules.deployInstall

import org.folio.Constants
import org.folio.models.EurekaNamespace
import org.folio.models.RancherNamespace
import org.folio.models.module.FolioModule
import org.folio.models.module.ModuleBuildTool
import org.folio.models.module.ModuleType
import org.folio.rest_v2.PlatformType
import org.folio.utilities.GitHubClient
import org.folio.utilities.Logger
import org.jenkinsci.plugins.pipeline.modeldefinition.Utils
import org.jenkinsci.plugins.workflow.libs.Library

//TODO: Switch to the RANCHER-1334
@Library('pipelines-shared-library@RANCHER-2057-test') _


properties([
  buildDiscarder(logRotator(numToKeepStr: '10')),
  parameters([
    folioParameters.platform(),
    folioParameters.cluster('PLATFORM'),
    folioParameters.namespace(),
    text(name: 'INSTALL_JSON', description: '(Required) Install json list with modules to install.',
      defaultValue: '''[ {
    "id" : "folio_users-x.x.x",
    "action" : "enable"
}, {
    "id" : "mod-users-x.x.x",
    "action" : "enable"
} ]'''),
    booleanParam(name: 'DEPLOY', defaultValue: true, description: 'Set true to update HELM deployments'),
    booleanParam(name: 'INSTALL', defaultValue: true, description: 'Set true to install modules with OKAPI or upgrade with EUREKA'),
    folioParameters.configType(),
    folioParameters.agent(),
    folioParameters.refreshParameters()
  ])
])

if (params.REFRESH_PARAMETERS) {
  currentBuild.result = 'ABORTED'
  return
}

ansiColor('xterm') {
  node(params.AGENT) {
    Logger logger = new Logger(this, env.JOB_BASE_NAME)

    boolean isEureka = PlatformType.valueOf(params.PLATFORM) == PlatformType.EUREKA

    RancherNamespace namespace = (isEureka ? new EurekaNamespace(params.CLUSTER, params.NAMESPACE) : new RancherNamespace(params.CLUSTER, params.NAMESPACE))
      .withDeploymentConfigType(params.CONFIG_TYPE, folioTools.getPipelineBranch())

    stage('Check environment state') {
      if (!namespace.isActive(this)){
        logger.warning("Target environment is not running. Please start the environment and try again.")

        currentBuild.result = 'ABORTED'
        return
      }
    }

    try {
      stage('Init'){
        buildName "${namespace.getWorkspaceName()}.${env.BUILD_ID}"
      }

//      stage('[Env] Scanning') {
//        eureka.getExistedTenantsFlow().values()
//                .each {namespace.addTenant(it)}
//      }
//
//      stage("[Env] Retrieve sidecar") {
//        folioHelm.withKubeConfig(namespace.getClusterName()) {
//          String sidecarImage = !updateAll ? kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), moduleName, "sidecar") : ""
//
//          // In case updated module doesn't have Sidecar let's seek for it in other modules.
//          if(!sidecarImage) {
//            EurekaModule moduleWithSidecar = namespace.modules.getInstallJsonObject().find { fetchedModule ->
//              kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), fetchedModule.getName(), "sidecar")
//                .replace(':', '-')
//            }
//
//            sidecarImage =
//              kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), moduleWithSidecar.getName(), "sidecar")
//          }
//
//          if(sidecarImage)
//            namespace.modules.addModule(sidecarImage.replace(':', '-'))
//          else
//            throw new AbortException('There are no modules with sidecar in the namespace')
//        }
//
//        logger.debug("Configured Tenants: ${namespace.tenants}")
//        logger.debug("Configured Applications: ${namespace.applications}")
//        logger.debug("Namespace modules: ${namespace.modules.installJsonObject}")
//      }
//
//      stage("[Env] Retrieve core modules") {
//        folioHelm.withKubeConfig(namespace.getClusterName()) {
//
//
//          String kong = kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), "kong-${namespace.getNamespaceName()}")
//          String keycloak = kubectl.getStatefulSetContainerImage(namespace.getNamespaceName(), "keycloak-${namespace.getNamespaceName()}")
//          String mgrApp = kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), "mgr-applications")
//          String mgrTenants = kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), "mgr-tenants")
//          String mgrTenantEnt = kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), "mgr-tenant-entitlements")
//
//          logger.debug("Kong: ${kong}")
//          logger.debug("Keycloak: ${keycloak}")
//          logger.debug("Mgr Applications: ${mgrApp}")
//          logger.debug("Mgr Tenants: ${mgrTenants}")
//          logger.debug("Mgr Tenant Entitlements: ${mgrTenantEnt}")
//        }
//      }

//      input message: "Let's wait"
    } catch (e) {
      logger.warning("Caught exception: ${e}")
      error(e.getMessage())
    } finally {
      stage('Cleanup') {
        logger.debug("Workspace size: ${sh(returnStdout: true, script: 'du -sh .').trim()}")
        cleanWs notFailBuild: true
      }
    }
  }
}
