package v2.applications.buildPush

import org.folio.Constants
import org.folio.models.FolioInstallJson
import org.folio.models.application.Application
import org.folio.models.module.EurekaModule
import org.folio.models.module.FolioModule
import org.folio.models.module.ModuleBuildTool
import org.folio.models.module.ModuleType
import org.folio.pipelines.applications.buildPush.ApplicationsBuildPushPipeline
import org.folio.utilities.Logger
import org.jenkinsci.plugins.pipeline.modeldefinition.Utils
import org.jenkinsci.plugins.workflow.libs.Library

//TODO: Switch to the master
@Library('pipelines-shared-library@RANCHER-2138-test') _

properties([
  buildDiscarder(logRotator(numToKeepStr: '10')),
  parameters([
    booleanParam(name: 'FROM_REPOSITORY', defaultValue: true, description: 'Check for building from application repository'),
    folioParameters.applicationSet(),
    folioParameters.application(),
    folioParameters.branchWithRef('APPLICATION_BRANCH', 'APPLICATION'),

    booleanParam(name: 'FROM_DESCRIPTOR', defaultValue: false, description: 'Check to upgrade previously built descriptor'),
    booleanParam(name: 'RECREATE', defaultValue: true, description: 'Check to recreate application descriptor from scratch with new module versions'),
    booleanParam(name: 'UPGRADE', defaultValue: false, description: 'Check to upgrade previously built descriptor with new module versions'),
    text(name: 'APPLICATION_DESCRIPTOR', description: 'Previously generated application descriptor.',
      defaultValue: '''[
  "id": "app-platform-minimal-x.x.x",
  "name": "app-platform-minimal",
  "version": "x.x.x",
  "description": "Minimal FOLIO platform installation",
  "platform": "base",
  "dependencies": [],
  "modules": [
    {
      "id": "mod-users-bl-x.x.x",
      "name": "mod-users-bl",
      "version": "x.x.x"
    }
    ],
    "uiModules": [
    {
      "id": "folio_developer-x.x.x",
      "name": "folio_developer",
      "version": "x.x.x"
    }
    ],
  "moduleDescriptors": [
    {
      "id": "mod-users-bl-7.10.0",
      "name": "users business logic",
      "requires": [
        {
          "id": "users",
          "version": "x.x"
        }
        ...............
        ]
    }
  ],
  "uiModuleDescriptors": [
    {
      "id": "folio_developer-10.0.0",
      "name": "Developer settings",
      "requires": [
        {
          "id": "okapi",
          "version": "1.9"
        }
      ]
      .......................
    }
  ]
]'''),

    booleanParam(name: 'FROM_TEMPLATE', defaultValue: false, description: 'Check for building from template'),
    string(name: 'APP_NAME', defaultValue: 'app-platform-minimal', description: '(Mandatory) Name of the application to be built'),
    string(name: 'APP_DESCRIPTION', defaultValue: '', description: '(Optional) Description of the application to be built'),
    text(name: 'TEMPLATE', description: 'Application template to use for building application descriptor.',
      defaultValue: '''[
  "name": "${project.name}",
  "version": "${project.version}",
  "description": "${project.description}",
  "platform": "base",
  "dependencies": [],
  "modules": [
    {
      "name": "mod-configuration",
      "version": "x.x.x"
    },
    {
      "name": "mod-permissions",
      "version": "latest"
    }
  ],
  "uiModules": [
    {
      "name": "folio_developer",
      "version": "x.x.x"
    },
    {
      "name": "folio_tags",
      "version": "latest"
    }
  ]
]'''),

    text(name: 'INSTALL_JSON', description: '(Required) Install json list with modules to install.',
      defaultValue: '''[
 {
    "id" : "folio_users-x.x.x",
    "action" : "enable"
  },
  {
    "id" : "mod-users-x.x.x",
    "action" : "enable"
  }
]'''),

    string(name: 'VERSION', defaultValue: '', description: '(Optional) A version to be explicitly set for new application descriptor.'),
    booleanParam(name: 'PUSH_DESCRIPTOR_TO_ECR', defaultValue: true, description: 'Set true to push application descriptor to the ECR repository'),
    folioParameters.agent(),
    folioParameters.refreshParameters()

    , folioParameters.groupCheckboxes([ 'FROM_REPOSITORY', 'FROM_DESCRIPTOR', 'FROM_TEMPLATE' ])
    , folioParameters.groupCheckboxes([ 'RECREATE', 'UPGRADE' ])

    , folioParameters.hideParameters(
    [
      '' :[ 'APPLICATION_SET', 'APPLICATION', 'APPLICATION_BRANCH' ],
      'on': [ 'VERSION' ]
    ]
    , "FROM_REPOSITORY", "FROM_REPOSITORY,FROM_DESCRIPTOR,FROM_TEMPLATE")

    , folioParameters.hideParameters(
    [
      '' :[ 'APPLICATION_DESCRIPTOR', 'RECREATE', 'UPGRADE' ]
    ]
    , "FROM_DESCRIPTOR", "FROM_REPOSITORY,FROM_DESCRIPTOR,FROM_TEMPLATE")

    , folioParameters.hideParameters(
    [
      '' :[ 'TEMPLATE', 'APP_NAME', 'APP_DESCRIPTION' ]
    ]
    , "FROM_TEMPLATE", "FROM_REPOSITORY,FROM_DESCRIPTOR,FROM_TEMPLATE")
  ])
])

// Abort if refresh parameters is set or if no source type is selected
// or if template source type is selected without any approach type
if (params.REFRESH_PARAMETERS || !(params.FROM_REPOSITORY || params.FROM_DESCRIPTOR || params.FROM_TEMPLATE) ||
      (params.FROM_TEMPLATE && !(params.RECREATE || params.UPGRADE))) {
  currentBuild.result = 'ABORTED'
  return
}

ansiColor('xterm') {
  node(params.AGENT) {
    Logger logger = new Logger(this, env.JOB_BASE_NAME)

    List<Map<String, String>> installJson = params.INSTALL_JSON.trim() ? readJSON(text: params.INSTALL_JSON) : [:]
    installJson = installJson.unique()

    FolioInstallJson<EurekaModule> beUpdated = new FolioInstallJson<EurekaModule>(EurekaModule.class)
      .setInstallJsonObject(installJson)

    Map initialDescriptor = readJSON text: params.APPLICATION_DESCRIPTOR
    Map template = readJSON text: params.TEMPLATE

    ApplicationsBuildPushPipeline.SourceType sourceType =
      params.FROM_REPOSITORY ? ApplicationsBuildPushPipeline.SourceType.REPOSITORY :
      (params.FROM_DESCRIPTOR ? ApplicationsBuildPushPipeline.SourceType.DESCRIPTOR :
        ApplicationsBuildPushPipeline.SourceType.TEMPLATE)

    String appName = ""
    Application application

    try {
      stage('Init'){
        String additionalInfo = null

        switch (sourceType) {
          case ApplicationsBuildPushPipeline.SourceType.REPOSITORY:
            appName = params.APPLICATION
            additionalInfo = "Branch: ${params.APPLICATION_BRANCH}"
            break

          case ApplicationsBuildPushPipeline.SourceType.DESCRIPTOR:
            appName = initialDescriptor.name
            additionalInfo = "Approach: ${params.RECREATE ? 'Recreate' : 'Upgrade'}"
            break

          case ApplicationsBuildPushPipeline.SourceType.TEMPLATE:
            appName = params.APP_NAME
            break
        }

        buildName "${appName}${params.VERSION ? ".${params.VERSION}" : ""}.${env.BUILD_ID}"
        buildDescription additionalInfo ?: ""
      }

      stage('[Maven] Build descriptor') {
        switch (sourceType) {
          case ApplicationsBuildPushPipeline.SourceType.REPOSITORY:
            application = new Application(folioEurekaAppGenerator.generateFromRepository(
              appName,
              beUpdated,
              params.APPLICATION_BRANCH as String
            ) as Map)
            break

          case ApplicationsBuildPushPipeline.SourceType.DESCRIPTOR:
            if(params.RECREATE) {
              application = new Application(folioEurekaAppGenerator.generateFromDescriptor(
                initialDescriptor,
                beUpdated,
                params.VERSION.trim() ?: null
              ) as Map)
            } else {
              application = new Application(folioEurekaAppGenerator.updateDescriptor(
                initialDescriptor,
                beUpdated
              ) as Map)
            }
            break

          case ApplicationsBuildPushPipeline.SourceType.TEMPLATE:
            application = new Application(folioEurekaAppGenerator.generateFromTemplate(
              appName,
              template,
              beUpdated,
              params.APPLICATION_DESCRIPTOR.trim() ?: null,
              params.VERSION.trim() ?: null
            ) as Map)
            break
        }
      }

      stage('[ECR] Upload descriptor') {
        if (!params.PUSH_DESCRIPTOR_TO_ECR) {
          logger.info("Skip [ECR] Upload descriptor stage")
          Utils.markStageSkippedForConditional('[ECR] Upload descriptor')
        }else{
          writeJSON file: application.getId() + '.json', json: application.getDescriptor()

          //noinspection GroovyAssignabilityCheck
          sh(
            label: "Upload an application descriptor to ECR",
            returnStdout: false,
            script: "[ -e ${application.getId()}.json ] && curl -sS -X PUT ${Constants.EUREKA_REGISTRY_URL}${application.getId()} --upload-file ${application.getId()}.json"
          )

          zip zipFile: application.getId() + '.json', glob: '**/' + application.getId() + '.json'
          archiveArtifacts allowEmptyArchive: true, artifacts: "${application.getId()}.json", fingerprint: true, defaultExcludes: false
        }
      }
    } catch (e) {
      logger.warning("Caught exception: ${e}")
      error(e.getMessage())
    } finally {
      stage('Cleanup') {
        logger.debug("Workspace size: ${sh(returnStdout: true, script: 'du -sh .').trim()}")
        cleanWs notFailBuild: true
      }
    }
  }
}
