#!groovy
package folioRancher.folioQualityGates

import org.folio.Constants as CommonConstants
import org.folio.models.ChangelogEntry
import org.folio.models.OkapiTenant
import org.folio.models.OkapiUser
import org.folio.models.parameters.CreateNamespaceParameters
import org.folio.models.parameters.CypressTestsParameters
import org.folio.models.parameters.KarateTestsParameters
import org.folio.rest_v2.Constants
import org.folio.slack.SlackHelper
import org.folio.testing.TestType
import org.folio.testing.cypress.results.CypressRunExecutionSummary
import org.folio.testing.karate.results.KarateRunExecutionSummary
import org.folio.utilities.Logger
import org.jenkinsci.plugins.workflow.libs.Library

@Library('pipelines-shared-library@RANCHER-1692') _

properties([
//  pipelineTriggers([cron('H 6,9,12,15,18,21 * * 1-5')]),
  buildDiscarder(logRotator(numToKeepStr: '40')),
  disableConcurrentBuilds(),
  parameters([
    string(name: 'FOLIO_BRANCH', defaultValue: 'snapshot', description: 'platform-complete branch where will be run quality CI job'),
    booleanParam(name: 'SKIP_CHECK', defaultValue: true, description: 'Skip check of changes since last build.'),
    folioParameters.agent(),
    folioParameters.refreshParameters()])
])

if (params.REFRESH_PARAMETERS) {
  currentBuild.result = 'ABORTED'
  return
}

Logger logger = new Logger(this, env.JOB_BASE_NAME)

boolean autoCanceled = false
String currentBuildSha
String previousBuildSha
CypressRunExecutionSummary cypressTestsExecutionSummary
KarateRunExecutionSummary karateTestsExecutionSummary

String createNamespaceFromBranchJob = CommonConstants.JENKINS_CREATE_NAMESPACE_FROM_BRANCH_JOB
String deleteNamespaceJob = CommonConstants.JENKINS_DELETE_NAMESPACE_JOB
String globalSlackChannel = '#rancher-test-notifications'
String okapiVersion = folioTools.eval(folioStringScripts.getOkapiVersions(), ['FOLIO_BRANCH': params.FOLIO_BRANCH])[0]

Map envsMap = [
  karate : [cluster: 'folio-testing', namespace: 'cikarate-yi']
//  cypress: [cluster: 'folio-testing', namespace: 'cicypress-yi'],
//  schema : [cluster: 'folio-tmp', namespace: 'cischema-yi']
]

CreateNamespaceParameters namespaceBaseParams = new CreateNamespaceParameters.Builder()
  .rwSplit(false)
  .greenmail(false)
  .mockServer(true)
  .pgType('built-in')
  .pgVersion('16.1')
  .kafkaType('built-in')
  .opensearchType('built-in')
  .s3Type('built-in')
  .runSanityCheck(false)
  .members('')
  .worker(params.AGENT)
  .build()

CreateNamespaceParameters namespaceFromBranchParams = namespaceBaseParams.toBuilder()
  .folioBranch(params.FOLIO_BRANCH)
  .okapiVersion(okapiVersion)
  .configType('testing')
  .loadReference(true)
  .loadSample(true)
  .consortia(true)
  .linkedData(true)
  .splitFiles(true)
  .rtr(false)
  .build()

ansiColor('xterm') {
  node(params.AGENT) {
    try {
      stage('Ini') {
        buildName "#${env.BUILD_ID}"
      }

      stage('Check Changes') {
        if (params.SKIP_CHECK) {
          logger.info("Skip check of changes since last build.")
        } else {
          currentBuildSha = folioHashCommitCheck.getCurrentBuildSha(params.FOLIO_BRANCH)
          previousBuildSha = folioHashCommitCheck.getPreviousBuildSha()
          boolean diffFound = folioHashCommitCheck.isInstallJsonChanged(previousBuildSha, currentBuildSha)

          if (diffFound) {
            logger.info('Incoming changes found. Proceed with build stages.')
          } else {
            buildDescription 'Skipped'
            logger.warning('Incoming changes not found. Skip build...')
            currentBuild.result = 'ABORTED'
            autoCanceled = true
            slackSend(attachments: folioSlackNotificationUtils.renderAbortedBuildResultMessage(), channel: globalSlackChannel)
          }
        }
      }

      if (autoCanceled) {
        return
      }

//      destroyParallelStage(deleteNamespaceJob, envsMap, namespaceBaseParams, globalSlackChannel)

      provisionFromBranchParallelStage(createNamespaceFromBranchJob, envsMap, namespaceFromBranchParams, globalSlackChannel)

//      stage('Execute quality gates') {
//        Map branches = [failFast: false]
//        branches['Cypress'] = { ->
//          CypressTestsParameters cypressParameters = new CypressTestsParameters()
//          cypressParameters.setCiBuildId(env.JOB_BASE_NAME)
//          cypressParameters.setTestsSrcBranch('master')
//          cypressParameters.setTenantUrl("https://${envsMap['cypress']['cluster']}-${envsMap['cypress']['namespace']}-diku.${Constants.CI_ROOT_DOMAIN}")
//          cypressParameters.setOkapiUrl("https://${envsMap['cypress']['cluster']}-${envsMap['cypress']['namespace']}-okapi.${Constants.CI_ROOT_DOMAIN}")
//          cypressParameters.setTenant(new OkapiTenant('diku')
//            .withAdminUser(new OkapiUser('diku_admin', 'admin')))
//          cypressParameters.setExecParameters('--env grepTags="shiftLeft"')
//          cypressParameters.setWorkerLabel('cypress-ci')
//          cypressParameters.setNumberOfWorkers(4)
//          cypressParameters.setTimeout('120')
//
//          cypressTestsExecutionSummary = folioCypressFlow.runWrapper(cypressParameters.getCiBuildId(), true, 'ci', false) {
//            folioCypressFlow.multiThreadRun(cypressParameters)
//          }
//        }
//        branches['Karate'] = { ->
//          KarateTestsParameters karateTestsParams = new KarateTestsParameters()
//          karateTestsParams.okapiUrl = "https://${envsMap['karate']['cluster']}-${envsMap['karate']['namespace']}-okapi.${Constants.CI_ROOT_DOMAIN}"
//          karateTestsParams.edgeUrl = "https://${envsMap['karate']['cluster']}-${envsMap['karate']['namespace']}-edge.${Constants.CI_ROOT_DOMAIN}"
//          karateTestsParams.tenant = 'supertenant'
//          karateTestsParams.prototypeTenant = 'consortium'
//          karateTestsParams.adminUserName = 'super_admin'
//          karateTestsParams.adminPassword = 'admin'
//          karateTestsParams.threadsCount = '4'
//          karateTestsParams.reportPortalProjectName = 'junit5-integration'
//          karateTestsParams.sendSlackNotification = false
//          karateTestsParams.sendTeamsSlackNotification = true
//          karateTestsParams.syncWithJira = true
//          karateTestsParams.timeout = '3'
//          karateTestsExecutionSummary = folioKarateFlow(karateTestsParams)
//        }
//        parallel(branches)
//      }

      stage('[AWS] Update ssm') {
        if (currentBuildSha) {
          folioHashCommitCheck.updateBuildSha(currentBuildSha)
        }
      }

      stage('[Slack] Send notification') {
        String karateTestsResultMessage = folioSlackNotificationUtils.renderTestResultSection(TestType.KARATE,
          karateTestsExecutionSummary, "", true,
          "${env.BUILD_URL}cucumber-html-reports/overview-features.html"
        )

        String cypressTestsResultMessage = folioSlackNotificationUtils.renderTestResultSection(TestType.CYPRESS,
          cypressTestsExecutionSummary, "", true, "${env.BUILD_URL}allure/"
        )

        String changelog = ''
        if (previousBuildSha && currentBuildSha) {
          List<ChangelogEntry> changelogEntriesList = folioChangeLog.call(previousBuildSha, currentBuildSha)
          changelog = folioChangeLog.renderChangelogSection(changelogEntriesList)
          buildDescription "Changelog:\n${folioChangeLog.getPlainText(changelogEntriesList)}"
        }

        String attachments = SlackHelper.renderMessage([
          folioSlackNotificationUtils.renderBuildResultSection(),
          cypressTestsResultMessage,
          karateTestsResultMessage,
          changelog
        ])

        slackSend(attachments: attachments, channel: "#rancher_tests_notifications")
      }
    } catch (e) {
      logger.error("Caught exception: ${e}")
    } finally {
      if (!autoCanceled) {
        destroyParallelStage(deleteNamespaceJob, envsMap, namespaceBaseParams, globalSlackChannel)
      }
      stage('Cleanup') {
        println("Workspace size: ${sh(returnStdout: true, script: 'du -sh . || true').trim()}")
        cleanWs notFailBuild: true
      }
    }
  }
}

void provisionFromBranchParallelStage(String jobName, Map envsMap, CreateNamespaceParameters namespaceFromBranchParams, String slackChannel) {
  /** Sub-Task object */
  def jobResult

  stage('Provisioning') {
    try {
      CreateNamespaceParameters namespaceCreateParams = namespaceFromBranchParams.toBuilder()
        .clusterName('folio-testing')
        .namespaceName('cikarate-yi')
        .build()

      jobResult = folioTriggerJob.createNamespaceFromBranch(jobName, namespaceCreateParams)

      println(jobResult?.dump())
      println(jobResult?.getDisplayName())
      println(jobResult?.getResult())
      println(jobResult?.getDescription())
      println(jobResult?.isBuilding())
      println(jobResult?.getProjectName())
      println(jobResult?.getAbsoluteUrl())
      println(jobResult?.getBuiltOnStr())
      println(jobResult?.getEnvironment())

//      Map branches = [failFast: false]
//      envsMap.each { id, metadata ->
//        CreateNamespaceParameters namespaceCreateParams = namespaceFromBranchParams.toBuilder()
//          .clusterName(metadata['cluster'])
//          .namespaceName(metadata['namespace'])
//          .build()
//        branches["${namespaceCreateParams.getClusterName()}-${namespaceCreateParams.getNamespaceName()}"] = { ->
//          def jobResult = folioTriggerJob.createNamespaceFromBranch(jobName, namespaceCreateParams)
//          println(jobResult.dump())
//        }
//      }
//      parallel(branches)
    } catch (e) {
      println(jobResult?.toString())
      println(jobResult?.dump())
      currentBuild.result = 'FAILURE'
      slackSend(attachments: folioSlackNotificationUtils.renderBuildResultMessage(), channel: slackChannel)
      throw new Exception("Provision of the environment is failed: " + e)
    }
  }
}

void destroyParallelStage(String jobName, Map namespacesMap, CreateNamespaceParameters namespaceBaseParams, String slackChannel) {
  stage('Destroy') {
    try {
      Map branches = [failFast: false]
      namespacesMap.each { id, metadata ->
        CreateNamespaceParameters namespaceDeleteParams = namespaceBaseParams.toBuilder()
          .clusterName(metadata['cluster'])
          .namespaceName(metadata['namespace'])
          .build()
        branches["${namespaceDeleteParams.getClusterName()}-${namespaceDeleteParams.getNamespaceName()}"] = { ->
          folioTriggerJob.deleteNamespace(jobName, namespaceDeleteParams)
        }
      }
      parallel(branches)
    } catch (e) {
      currentBuild.result = 'FAILURE'
      slackSend(attachments: folioSlackNotificationUtils.renderBuildResultMessage(), channel: slackChannel)
      throw new Exception("Destroy of the environment is failed: " + e)
    }
  }
}

getNumber(): Returns the build number. This is an integer that uniquely identifies the build within its job.

getResult(): Returns the result of the build, which can be one of several statuses:

  SUCCESS: The build had no errors.
FAILURE: The build had a fatal error.
  UNSTABLE: The build was marked unstable, for example, if tests failed or some other issue was detected.
  ABORTED: The build was manually aborted.
  NOT_BUILT: The build was skipped.
getDisplayName(): Provides a human-readable display name for the build, typically consisting of the job name followed by the build number.

  isBuilding(): Returns a boolean indicating whether the build is currently running.

getDuration(): Returns the duration of the build in milliseconds.

  getStartTimeInMillis(): Returns the start time of the build as milliseconds since the epoch.

getBuiltOnStr(): Returns the name of the agent or node where the build was executed.

getArtifacts(): Returns a list of artifacts produced by the build. Each artifact in the list is represented by an object with properties like fileName and relativePath.

getAbsoluteUrl(): Returns the absolute URL to the build on the Jenkins server, which can be used to access the build's webpage directly.

getProjectName(): Returns the name of the job that this build belongs to.

getPreviousBuild(), getNextBuild(): Methods to navigate to the previous or next build in the job's build history.

getDescription(): Returns the description of the build, if any was set.

getEnvironment(TaskListener listener): Allows you to get a map of the environment variables that were in effect during the build. Note that you need to pass a TaskListener to thi
