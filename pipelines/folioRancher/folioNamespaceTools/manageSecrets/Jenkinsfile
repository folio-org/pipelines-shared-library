#!groovy
import groovy.json.JsonOutput
import org.folio.Constants
import org.folio.rest.GitHubUtility
import org.folio.utilities.Tools
import org.jenkinsci.plugins.workflow.libs.Library

LIB_BRANCH = 'RANCHER-834'
@Library('pipelines-shared-library@RANCHER-834') _

properties([
  buildDiscarder(logRotator(numToKeepStr: '20')),
  disableConcurrentBuilds(),
  parameters([
      jobsParameters.clusterName(),
      jobsParameters.projectName(),
      jobsParameters.secretOperations(),
      booleanParam(defaultValue: false, description: '', name: 'Json'),
      string(defaultValue: '', description: '(Required for all 3 operations: create, delete & update)', name: 'secret_name'),
      string(defaultValue: '', description: '(Required for operations: create & update)', name: 'secret_value'),
      jobsParameters.agents(),
      jobsParameters.refreshParameters()
  ])
])

ansiColor('xterm') {
  if (params.refresh_parameters) {
    currentBuild.result = 'ABORTED'
    println('REFRESH JOB PARAMETERS!')
    return
  }
  node(params.agent) {
    try {
      stage('Checkout') {
        checkout scm
      }

      if (params.JSON && params.operation_type == 'create') {
           stage('Json secret create') {
             echo 'JSON!'
             withKubeCredentials(kubectlCredentials: [[clusterName: "${rancher_cluster_name}", credentialsId: Constants.AWS_CREDENTIALS_ID, namespace: "${rancher_project_name}", serverUrl: '']]) {
             //awscli.getKubeConfig(Constants.AWS_REGION, params.rancher_cluster_name)
             kubectl.createSecretWithJson(params.rancher_project_name, "${secret_name}", "${secret_value}")
             }
          }
        }
      if (params.operation_type == 'delete') {
           stage('secret delete') {
             println("Deleting secret: ${secret_name}")
             awscli.getKubeConfig(Constants.AWS_REGION, params.rancher_cluster_name)
             kubectl.deleteSecret(params.rancher_project_name, "${secret_name}")
          }
        }

    } catch (exception) {
      println(exception)
      error(exception.getMessage())
    } finally {
      stage('Cleanup') {
        cleanWs notFailBuild: true
      }
    }
  }
}
