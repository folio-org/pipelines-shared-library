package folioRancher.v2.utils.moduleBuildPush

import groovy.transform.Field
import org.folio.Constants
import org.folio.utilities.GitHubClient
import org.folio.utilities.Logger
import org.jenkinsci.plugins.workflow.libs.Library

//TODO: Switch to the RANCHER-1334
@Library('pipelines-shared-library@RANCHER-2057-test') _

enum ProjectType {
  MAVEN, GRADLE
}

properties([
  buildDiscarder(logRotator(numToKeepStr: '30')),
  parameters([
    folioParameters.moduleName(null), // MODULE_NAME, Folio Module moduleName
    folioParameters.branchWithRef('MODULE_BRANCH', 'MODULE_NAME'), // MODULE_BRANCH, Module Github branch
    string(name: 'MAVEN_ARGS', defaultValue: '-DskipTests', description: 'Maven build arguments'),
    booleanParam(name: 'PUSH_IMAGE_TO_ECR', defaultValue: true, description: 'Set true to push built image to the ECR repository'),
    booleanParam(name: 'PUSH_DESCRIPTOR_TO_ECR', defaultValue: true, description: 'Set true to push module descriptor to the ECR repository'),
    folioParameters.agent(Constants.JENKINS_AGENTS_BUILD_MODULE),
    folioParameters.refreshParameters()
  ])
])

if (params.REFRESH_PARAMETERS) {
  currentBuild.result = 'ABORTED'
  return
}

Logger logger = new Logger(this, env.JOB_BASE_NAME)

String moduleName = params.MODULE_NAME
String branch = params.MODULE_BRANCH
String mavenArgs = params.MAVEN_ARGS.trim()
String gradleOpts = '--quiet --console plain --no-daemon'

ansiColor('xterm') {
  node(params.AGENT) {
    try {
      stage('Init') {
        buildName "#${params.MODULE_NAME}.${env.BUILD_ID}"

        buildDescription """Module: $moduleName
Branch: ${branch}"""
      }

      stage('[Git] Checkout module source') { // GitHub. Download module source to build
        checkout([
          $class           : 'GitSCM',
          branches         : [[name: "*/${branch}"]],
          extensions       : [[$class: 'RelativeTargetDirectory', relativeTargetDir: moduleName],
                              [$class: 'CleanBeforeCheckout', deleteUntrackedNestedRepositories: true],
                              [$class: 'AuthorInChangelog'],
                              [$class: 'SubmoduleOption', recursiveSubmodules: true]],
          userRemoteConfigs: [[url: "https://github.com/folio-org/${moduleName}.git"]]
        ])
      }

      stage('[Maven/Gradle] Build artifact') {
        String commitHash = new GitHubClient(Jenkinsfile).getBranchInfo(moduleName, branch).commit.sha.take(7)
        String moduleId = compile(moduleName, commitHash, mavenArgs, gradleOpts, logger)

        buildDescription """Module: $moduleId
Branch: ${branch}"""
      }

      stage('[Docker] Build image and push') {
        when {
          expression { return params.PUSH_IMAGE_TO_ECR }
        }

        input message: "Let's wait"

        deployAppModule.buildAndPushContainerImage(logger, module)
      }

//      stage('[CURL] Upload module descriptor') {
//        when {
//          expression { return params.PUSH_DESCRIPTOR_TO_ECR }
//        }
//        steps {
//          script {
//            deployAppModule.putModuleDescriptorToRegistry(logger, module)
//          }
//        }
//      }
    } catch (e) {
      logger.warning("Caught exception: ${e}")
      error(e.getMessage())
    } finally {
      stage('Cleanup') {
        logger.debug("Workspace size: ${sh(returnStdout: true, script: 'du -sh .').trim()}")
        cleanWs notFailBuild: true
      }
    }
  }
}

String compileMaven(String moduleName, String commitHash, String mavenArgs, Logger logger = new Logger(this, env.JOB_BASE_NAME)) {
  logger.info("Maven build tool is used")
  String buildDir = "${env.WORKSPACE}/${moduleName}"

  dir(buildDir) {
    String moduleVersion = readMavenPom(file: 'pom.xml').version

    moduleVersion += ".$commitHash"

    withMaven(
      jdk: "${common.selectJavaBasedOnAgent(params.AGENT)}".toString(),
      maven: Constants.MAVEN_TOOL_NAME,
      traceability: false,
      options: [artifactsPublisher(disabled: true)])
      {
        sh(
          label: 'Build with Maven', script: """
            mvn versions:set -DnewVersion=${moduleVersion}
            mvn package ${mavenArgs}
          """.stripIndent().trim()
        )
      }

    return "${moduleName}-${moduleVersion}"
  }
}

String compileGradle(String moduleName, String commitHash, String gradleOpts, Logger logger = new Logger(this, env.JOB_BASE_NAME)) {
  logger.info("Gradle build tool is used")
  String buildDir = "${env.WORKSPACE}/${moduleName}/service"

  dir(buildDir) {
    String moduleVersion = readProperties(file: "gradle.properties")['appVersion']

    if(!moduleVersion.contains("-SNAPSHOT")) {
      moduleVersion += "-SNAPSHOT"
    }

    moduleVersion += ".$commitHash"

    sh(label: 'Build with Gradle', script: "./gradlew ${gradleOpts} -PappVersion=${moduleVersion} assemble")

    return "${moduleName}-${moduleVersion}"
  }
}

String compile(String moduleName, String commitHash, String mavenArgs, String gradleOpts, Logger logger = new Logger(this, env.JOB_BASE_NAME)) {
  switch (getProjectType(moduleName)) {
    case ProjectType.MAVEN:
      return compileMaven(moduleName, commitHash, mavenArgs, logger)
      break

    case ProjectType.GRADLE:
      return compileGradle(moduleName, commitHash, gradleOpts, logger)
      break

    default:
      throw new RuntimeException("Unsupported build tool for module: ${moduleName}")
  }
}

ProjectType getProjectType(String moduleName){
  boolean hasPom = fileExists("${moduleName}/pom.xml")
  boolean hasGradle = fileExists("${moduleName}/build.gradle") || fileExists("${moduleName}/service/build.gradle")

  return hasPom ? ProjectType.MAVEN : (hasGradle ? ProjectType.GRADLE : null)
}
