#!groovy
/**
 * This Jenkins pipeline deploys Eureka module version from feature branch
 */
import org.folio.Constants
import org.folio.models.FolioModule
import org.folio.models.InstallRequestParams
import org.folio.models.EurekaTenant
import org.folio.models.RancherNamespace
import org.folio.rest_v2.Eureka
import org.folio.utilities.Logger

// TODO: RANCHER-1358 - get rid off custom branch mention once feature development is done
@Library('pipelines-shared-library@RANCHER-1358') _

/**
 * Job properties and parameters
 */
properties([
  buildDiscarder(logRotator(numToKeepStr: '30')),
  disableConcurrentBuilds(),
  parameters([
    folioParameters.cluster(),
    folioParameters.namespace(),
    folioParameters.moduleName(),
    folioParameters.branchWithRef('MODULE_BRANCH', 'MODULE_NAME'),
    folioParameters.configType(),
    string(name: 'MAVEN_ARGS', defaultValue: '-DskipTests', description: 'Maven build arguments'),
    folioParameters.loadReference(false),
    folioParameters.loadSample(false),
    folioParameters.ignoreErrors(),
    folioParameters.agent(),
    folioParameters.refreshParameters()
  ])
])

if (params.REFRESH_PARAMETERS) {
  currentBuild.result = 'ABORTED'
  return
}

/**
 * Job variables
 */
Logger logger = new Logger(this, env.JOB_BASE_NAME)

/**
 * Collect Folio module configuration
 */
FolioModule module = new FolioModule()
module.name = params.MODULE_NAME

/**
 * Collect feature branch and hash
 */
String featureBranch = params.MODULE_BRANCH
String featureHash = folioHashCommitCheck.getLatestCommitHash(module.getName(), featureBranch).take(7)

// Collect Maven arguments
String mavenArguments = params.MAVEN_ARGS.trim()
List installJson = []

/**
 * Collect install request parameters
 */
InstallRequestParams installRequestParams = new InstallRequestParams()
  .withTenantParameters("loadReference=${params.LOAD_REFERENCE},loadSample=${params.LOAD_SAMPLE}")
  .withIgnoreErrors(params.IGNORE_ERRORS)

RancherNamespace namespace = new RancherNamespace(params.CLUSTER, params.NAMESPACE)
  .withDeploymentConfigType(params.CONFIG_TYPE)

namespace.addDeploymentConfig(folioTools.getPipelineBranch())

Eureka folioApp = new Eureka(
        this,
        Constants.CI_ROOT_DOMAIN,
        true,
        namespace.masterTenant,
        "https://${namespace.getDomains()['keycloak']}",
        "https://${namespace.getDomains()['kong']}"
)

//TODO: RANCHER-1358: Disable stage flag for testing purposes
Boolean skipStage = true

/**
 * Pipeline
 */
ansiColor('xterm') {
  node(params.AGENT) {
    try {
      stage('Ini') {
        buildName "#${params.MODULE_NAME}.${env.BUILD_ID}"
        buildDescription "Env: ${namespace.getWorkspaceName()}\nBranch: ${params.MODULE_BRANCH}\n" + "Config: ${params.CONFIG_TYPE}\n${currentBuild.getBuildCauses()[0].shortDescription}"
      }

      stage('[Git] Checkout module source') {
        checkout([
          $class           : 'GitSCM',
          branches         : [[name: "*/${featureBranch}"]],
          extensions       : [[$class: 'RelativeTargetDirectory', relativeTargetDir: module.getName()],
                              [$class: 'CleanBeforeCheckout', deleteUntrackedNestedRepositories: true],
                              [$class: 'AuthorInChangelog'],
                              [$class: 'SubmoduleOption', recursiveSubmodules: true]],
          userRemoteConfigs: [[url: "https://github.com/folio-org/${module.getName()}.git"]]
        ])
      }

      stage('[Maven] Compile') {
        if (skipStage) {
          logger.warning("Stage [Maven] Compile is disabled")
        }
        else {
          dir(module.getName()) {
            String origVersion = readMavenPom(file: 'pom.xml').version
            module.version = "${origVersion}.${featureHash}"

            withMaven(jdk: "${common.selectJavaBasedOnAgent(params.AGENT)}".toString(),
              maven: Constants.MAVEN_TOOL_NAME,
              traceability: false,
              options: [artifactsPublisher(disabled: true)]) {
              sh """
              mvn versions:set -DnewVersion=${module.getVersion()}
              mvn package ${mavenArguments}
            """
            }

            String descriptorPath = "target/ModuleDescriptor.json"
            if (fileExists(descriptorPath)) {
              module.descriptor = [readJSON(file: descriptorPath)]
            }
          }
        }
      }

      stage('[Docker] Build and push') {
        if (skipStage) {
          logger.warning("Stage [Docker] Build and push is disabled")
        }
        else {
          common.checkEcrRepoExistence(module.getName())
          docker.withRegistry("https://${Constants.ECR_FOLIO_REPOSITORY}", "ecr:${Constants.AWS_REGION}:${Constants.ECR_FOLIO_REPOSITORY_CREDENTIALS_ID}") {
            dir(module.getName()) {
              def image = docker.build("${module.getName()}:${module.getVersion()}", '--no-cache=true --pull=true .')
              image.push()
            }
          }
        }
      }

      stage('Generate context') {
        if (skipStage) {
          logger.warning("Stage [Docker] Build and push is disabled")
        }
        else {
          installJson = [[
            "id": "${module.name}-${module.version}",
            "action": "enable"
          ]]
          Map folioTenants = folioDefault.getPredefinedTenants()
          folioApp.getTenantsList().each { tenantId ->
            if (tenantId == 'master' && module.name ==~ /mod-(permissions|users|login)/) {
              namespace.masterTenant.withInstallJson(installJson)
            } else {
              EurekaTenant appTenant = new EurekaTenant(tenantId)
              appTenant.withInstallJson(installJson)
              appTenant.withInstallRequestParams(installRequestParams.clone() as InstallRequestParams)

              namespace.addEurekaTenant(appTenant)
            }
          }
          namespace.modules.setInstallJson(installJson)
        }
      }

      stage('Update') {
        // 1. Register Application Descriptor with Updated Module Version
        // 1.1 Get Application Entitlements by Application ID Pattern and Tenant Short Name
        Map appEntitlements = folioApp.getAppEntitlements("app-platform-complete-*-SNAPSHOT.*", "diku")

        // Get Current Application Descriptor by its ID
        // {entitlements=[{applicationId=app-platform-complete-1.0.0-SNAPSHOT.155, tenantId=44f0a9af-4395-44b4-80a8-51cf03f8c897, modules=[]}], totalRecords=1}
        String appId = appEntitlements.entitlements[0].applicationId
        Map appDescriptor = folioApp.getApplicationDescriptor(appId)

        // 1.2 Get Updated Application Descriptor with new Module Version
        Map updatedAppDescriptor = folioApp.getUpdatedApplicationDescriptor(appDescriptor, module, env.BUILD_NUMBER)
        println(updatedAppDescriptor)

        // 1.3 Put back Updated Application Descriptor to Folio Instance
        // folioApp.registerApplication(updatedAppDescriptor)

        // 2. Enable New Module Version for Application
        // folioApp.createModuleDiscovery()

        // 3. Enable New Application Descriptor with Updated Module Version for Specific Tenant
        // folioApp.upgradeApplication()

        // 4. Deploy New Module Version to Namespace via Helm
        // folioDeployFlow.update()
      }

    } catch (e) {
      logger.warning("Caught exception: ${e}")
      error(e.getMessage())
    } finally {
      stage('Cleanup') {
        logger.debug("Workspace size: ${sh(returnStdout: true, script: 'du -sh .').trim()}")
        cleanWs notFailBuild: true
      }
    }
  }
}
