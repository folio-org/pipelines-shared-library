package folioRancher.folioDevTools.moduleDeployment.deployModuleFromFeatureBranchEureka

import org.folio.Constants
import org.folio.utilities.Logger
import org.folio.utilities.GitHubClient
import org.folio.models.EurekaNamespace
import org.folio.models.FolioModule
import org.folio.rest_v2.eureka.Eureka

// TODO: RANCHER-1700 - get rid off custom branch mention once feature development is done
@Library('pipelines-shared-library@RANCHER-1700') _

/** Job properties and parameters */
properties([
  buildDiscarder(logRotator(numToKeepStr: '30')),
  disableConcurrentBuilds(),
  parameters([
    folioParameters.moduleName(),
    folioParameters.branchWithRef('MODULE_BRANCH', 'MODULE_NAME'),
    string(name: 'MAVEN_ARGS', defaultValue: '-DskipTests', description: 'Maven build arguments'),
    folioParameters.cluster(),
    folioParameters.namespace(),
    folioParameters.configType(),
    folioParameters.agent(),
    folioParameters.refreshParameters(),
  ])
])

if (params.REFRESH_PARAMETERS) {
  currentBuild.result = 'ABORTED'
  return
}


/** Job variables */
Logger logger = new Logger(this, env.JOB_BASE_NAME)

/** Collect Rancher Namespace Configuration */
EurekaNamespace namespace = new EurekaNamespace(params.CLUSTER, params.NAMESPACE)
  .withDeploymentConfigType(params.CONFIG_TYPE) as EurekaNamespace

/** Assign Desired Resource Profile for Environment */
namespace.addDeploymentConfig(folioTools.getPipelineBranch())

/** Assign Default Tenant Id to Namespace instance */
String defaultTenantId = 'diku'
namespace.withDefaultTenant(defaultTenantId)

/** Collect Folio module configuration */
FolioModule module = new FolioModule()
module.name = params.MODULE_NAME

/** Collect feature branch and hash */
String featureBranch = params.MODULE_BRANCH
String featureHash = new GitHubClient(this).getBranchInfo(module.getName(), featureBranch).commit.sha.take(7)

/** Collect Maven arguments */
String mavenArguments = params.MAVEN_ARGS.trim()

/** Init Eureka Application Instance */
Eureka eureka = new Eureka(this, namespace.generateDomain('kong'), namespace.generateDomain('keycloak'), false)

/** Pipeline */
ansiColor('xterm') {
  node(params.AGENT) {
    try {
      stage('Ini') {
        buildName "#${params.MODULE_NAME}.${env.BUILD_ID}"
        buildDescription "Env: ${namespace.getWorkspaceName()}\nBranch: ${params.MODULE_BRANCH}\n" + "Config: ${params.CONFIG_TYPE}\n${currentBuild.getBuildCauses()[0].shortDescription}"
      }

      stage('[Git] Checkout module source') {
        checkout([
          $class           : 'GitSCM',
          branches         : [[name: "*/${featureBranch}"]],
          extensions       : [[$class: 'RelativeTargetDirectory', relativeTargetDir: module.name],
                              [$class: 'CleanBeforeCheckout', deleteUntrackedNestedRepositories: true],
                              [$class: 'AuthorInChangelog'],
                              [$class: 'SubmoduleOption', recursiveSubmodules: true]],
          userRemoteConfigs: [[url: "https://github.com/folio-org/${module.name}.git"]]
        ])
      }

      env.GRADLEW_OPTS = '--console plain --no-daemon'
      env.BUILD_DIR = "${env.WORKSPACE}/${module.getName()}/service"
      env.MD = "${env.WORKSPACE}/${module.getName()}/service/build/resources/main/okapi/ModuleDescriptor.json"

      stage('[Maven/Gradle] Compile') {
        echo "GRADLEW_OPTS: ${env.GRADLEW_OPTS}"
        echo "BUILD_DIR: ${env.BUILD_DIR}"
        echo "MD: ${env.MD}"

        dir(env.BUILD_DIR) {
          sh "./gradlew $env.GRADLEW_OPTS assemble"
        }

//        dir(module.getName()) {
//          String origVersion = readMavenPom(file: 'pom.xml').version
//          module.version = "${origVersion}.${featureHash}"
//          module.loadModuleDetails("${module.name}-${module.version}")
//
//          withMaven(
//            jdk: "${common.selectJavaBasedOnAgent(params.AGENT)}".toString(),
//            maven: Constants.MAVEN_TOOL_NAME,
//            traceability: false,
//            options: [artifactsPublisher(disabled: true)])
//          {
//            sh """
//              mvn versions:set -DnewVersion=${module.getVersion()}
//              mvn package ${mavenArguments}
//            """.stripIndent()
//          }
//
//          String descriptorPath = "target/ModuleDescriptor.json"
//          if (fileExists(descriptorPath)) {
//            // Switch "dockerImage" to "folioci" Organization in Module Descriptor
//            sh(script: "sed -i 's#\"dockerImage\": \"${module.name}:${module.version}\"#\"dockerImage\": \"folioci\\/${module.name}-${module.version}\"#g' ${descriptorPath}")
//            logger.debug("Module Descriptor:\n${readFile(descriptorPath)}")
//
//            // Upload Module Descriptor to Eureka Module Registry
//            sh(script: "curl -X PUT ${Constants.EUREKA_REGISTRY_URL}${module.name}-${module.version} --upload-file ${descriptorPath}")
//
//            module.descriptor = [readJSON(file: descriptorPath)]
//          }
//        }
      }

      env.dockerRepo = 'folioci'
      env.version = "7.1.0-SNAPSHOT.${env.BUILD_NUMBER}"

      stage('[Docker] Build and push') {
        dir(env.BUILD_DIR) {
          sh "./gradlew $env.GRADLEW_OPTS -PdockerRepo=${env.dockerRepo} buildImage"
        }

        // debug Module Descriptor
        sh "cat $env.MD"

        // Upload Module Descriptor to Eureka Module Registry
        sh(script: "curl -X PUT ${Constants.EUREKA_REGISTRY_URL}${module.name}-${module.version} --upload-file ${env.MD}")
//        common.checkEcrRepoExistence(module.getName())
//        docker.withRegistry("https://${Constants.ECR_FOLIO_REPOSITORY}", "ecr:${Constants.AWS_REGION}:${Constants.ECR_FOLIO_REPOSITORY_CREDENTIALS_ID}") {
//          dir(module.getName()) {
//            def image = docker.build("${module.getName()}:${module.getVersion()}", '--no-cache=true --pull=true .')
//            image.push()
//          }
//        }
      }
//
//      stage('Generate context') {
//        namespace.tenants = eureka.getExistedTenants()
//        logger.info("Configured Tenants: ${namespace.tenants}")
//
//        namespace.withApplications(eureka.getEnabledApplications(namespace.tenants))
//        logger.info("Configured Applications: ${namespace.applications}")
//
//        // TODO: RANCHER-1700 - get rid off custom branch mention once debugging is done
////        module.loadModuleDetails('mod-roles-keycloak-1.4.6-SNAPSHOT.8a01f13')
////        module.loadModuleDetails('mod-lists-2.1.0-SNAPSHOT.8e6c903')
//      }
//
//      /** Updated Applications Info Map<AppName, AppID> */
//      Map<String, String> updatedAppInfoMap = [:]
//
//      // 1. Register Application Descriptor with Updated Module Version
//      stage('[Rest] Update App Descriptor') {
//        updatedAppInfoMap = eureka.updateAppDescriptorFlow(namespace.applications, namespace.getModules(), module)
//      }
//
//      // 2. Enable New Module Version (Discovery) for Application
//      stage('[Rest] Module Discovery') {
//        eureka.runModuleDiscoveryFlow(module)
//      }
//
//      // 3. Deploy New Module Version to Rancher Namespace via Helm
//      stage('[Helm] Deploy Module Ver') {
//        folioHelm.withKubeConfig(namespace.clusterName) {
//          folioHelm.deployFolioModule(namespace, module.name, module.version, false, namespace.defaultTenantId)
//          echo "Module ${module.name}-${module.version} deployed to ${namespace.clusterName} namespace ${namespace.workspaceName}"
//          echo "Waiting another 3 minutes for the module to initialize..."
//          sleep time: 2, unit: 'MINUTES'
//        }
//      }
//
//      // 4. Enable Application Descriptor with Updated Module Version for Tenants in Namespace
//      stage('[Rest] Enable New App') {
//        eureka.enableApplicationsOnTenantsFlow(namespace.tenants, updatedAppInfoMap)
//      }
//
//      stage('[Rest] Remove Stale Resources') {
//        eureka.removeStaleResourcesFlow(namespace.applications, updatedAppInfoMap, module)
//      }

    } catch (e) {
      logger.warning("Caught exception: ${e}")
      error(e.getMessage())
    } finally {
      stage('Cleanup') {
        logger.debug("Workspace size: ${sh(returnStdout: true, script: 'du -sh .').trim()}")
        cleanWs notFailBuild: true
      }
    }
  }
}
