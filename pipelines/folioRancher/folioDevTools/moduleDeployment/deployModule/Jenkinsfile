package folioRancher.folioDevTools.moduleDeployment.deployModule

import hudson.AbortException
import org.folio.Constants
import org.folio.models.module.EurekaModule
import org.folio.utilities.Logger
import org.folio.models.EurekaNamespace
import org.folio.rest_v2.eureka.Eureka
import org.jenkinsci.plugins.workflow.libs.Library

// TODO: rollback to @RANCHER-1334 once code for this feature is tested
@Library('pipelines-shared-library@RANCHER-2026') _

/** Job properties and parameters */
properties([
  buildDiscarder(logRotator(numToKeepStr: '30')),
  disableConcurrentBuilds(),
  parameters([
    folioParameters.moduleName(), // MODULE_NAME, Folio Module name
    folioParameters.moduleSource(), // MODULE_SOURCE, Eureka Module source (Github, DockerHub, AWS ECR)
    folioParameters.branchWithRef('MODULE_BRANCH', 'MODULE_NAME'), // MODULE_BRANCH, Eureka Module Github branch
    folioParameters.containerImageTag('CONTAINER_IMAGE_TAG', 'MODULE_NAME, MODULE_SOURCE'), // CONTAINER_IMAGE_TAG, Container image tag
    folioParameters.cluster(),
    folioParameters.namespace(),
    folioParameters.configType(),
    folioParameters.agent(),
    folioParameters.refreshParameters(),
  ])
])

if (params.REFRESH_PARAMETERS) {
  currentBuild.result = 'ABORTED'
  return
}


/** Pipeline variables */
Logger logger = new Logger(this, env.JOB_BASE_NAME)

/** Collect Rancher Namespace Configuration */
EurekaNamespace namespace = new EurekaNamespace(params.CLUSTER, params.NAMESPACE)
  .withDeploymentConfigType(params.CONFIG_TYPE) as EurekaNamespace

/** Assign Desired Resource Profile for Environment */
namespace.addDeploymentConfig(folioTools.getPipelineBranch())

/** Assign Default Tenant Id to Namespace instance */
String defaultTenantId = 'diku'
namespace.withDefaultTenant(defaultTenantId)

/** Collect Folio module configuration */
EurekaModule module = new EurekaModule()
module.name = params.MODULE_NAME

/** Init Eureka Application Instance */
Eureka eureka = new Eureka(this, namespace.generateDomain('kong'), namespace.generateDomain('keycloak'), false)

/** Updated Applications Info Map<AppName, AppID> */
Map<String, String> updatedAppInfoMap = [:]

/** Pipeline */
ansiColor('xterm') {
  node(params.AGENT) {
    try {
      stage('Ini') {
        buildName "#${params.MODULE_NAME}.${env.BUILD_ID}"
        buildDescription "Env: ${namespace.getWorkspaceName()}\n" + "Config: ${params.CONFIG_TYPE}\n${currentBuild.getBuildCauses()[0].shortDescription}"

        // Load Module Details and set Module Version
        module.loadModuleDetails("${module.name}-${params.CONTAINER_IMAGE_TAG}")

        // Load Module Descriptor from Folio Descriptor Registry
        String getModuleDescriptorFromRegistry = "curl -s ${org.folio.rest_v2.Constants.OKAPI_REGISTRY}/_/proxy/modules/${module.name}-${module.version}"
        logger.debug("Module Descriptor URL: ${getModuleDescriptorFromRegistry}")
        String moduleDescriptor = sh(label: "Get Module Descriptor from Folio Descriptor Registry", returnStdout: true, script: getModuleDescriptorFromRegistry).trim()
        logger.debug("Module Descriptor: ${moduleDescriptor}")
        module.descriptor = [readJSON(text: moduleDescriptor)]

        // Upload Module Descriptor to Eureka Descriptor Registry
        sh( label: "Put Module Descriptor to Eureka Descriptor Registry",
            returnStdout: false,
            script: "curl -sS -X PUT ${Constants.EUREKA_REGISTRY_URL}${module.name}-${module.version} --data @- <<EOF\n${moduleDescriptor}\nEOF"
        )
      }

      stage('Generate context') {
        eureka.getExistedTenantsForModule(module).values()
          .each {namespace.addTenant(it)}

        if(!(namespace.tenants))
          throw new Exception("There are no tenants with the module ${module.getName()}")
      }

      stage("Retrieve module's sidecar"){
        folioHelm.withKubeConfig(namespace.getClusterName()) {
          String sidecarImage =
                  kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), module.getName(), "sidecar")
                          .replace(':', '-')

          // In case updated module doesn't have Sidecar let's seek for it in other modules.
          if(!sidecarImage) {
            EurekaModule moduleWithSidecar = namespace.modules.getInstallJsonObject().find { fetchedModule ->
              kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), fetchedModule.getName(), "sidecar")
                      .replace(':', '-')
            }

            sidecarImage =
              kubectl.getDeploymentContainerImageName(namespace.getNamespaceName(), moduleWithSidecar.getName(), "sidecar")
                      .replace(':', '-')
          }

          if(sidecarImage)
            namespace.modules.addModule(sidecarImage)
          else
            throw new AbortException('There are no modules with sidecar in the namespace')
        }

        logger.debug("Configured Tenants: ${namespace.tenants}")
        logger.debug("Configured Applications: ${namespace.applications}")
        logger.debug("Namespace modules: ${namespace.modules.installJsonObject}")
      }

      // 1. Register Application Descriptor with Updated Module Version
      stage('[Rest] Update App Descriptor') {
        try {
          updatedAppInfoMap = eureka.updateAppDescriptorFlow(namespace.applications, module)
        } catch (e) {
          logger.warning("Failed to register new application descriptor: ${e}")
          eureka.removeResourcesOnFailFlow(updatedAppInfoMap, module)
          throw e
        }
      }

      // 2. Enable New Module Version (Discovery) for Application
      stage('[Rest] Module Discovery') {
        try {
          eureka.runModuleDiscoveryFlow(module)
        } catch (e) {
          logger.warning("Failed to perform new module discovery: ${e}")
          eureka.removeResourcesOnFailFlow(updatedAppInfoMap, module)
          throw e
        }
      }

      // 3. Deploy New Module Version to Rancher Namespace via Helm
      stage('[Helm] Deploy Module Ver') {
        try {
          folioHelm.withKubeConfig(namespace.clusterName) {
            folioHelm.deployFolioModule(namespace, module.name, module.version, false, namespace.defaultTenantId)
            echo "Module ${module.name}-${module.version} deployed to ${namespace.clusterName} namespace ${namespace.workspaceName}"
            kubectl.checkDeploymentStatus(module.name, namespace.namespaceName, "300")
          }
        } catch (e) {
          logger.warning("Failed to deploy new module version via Helm: ${e}")
          eureka.removeResourcesOnFailFlow(updatedAppInfoMap, module)
          throw e
        }
      }

      // 4. Enable Application Descriptor with Updated Module Version for Tenants in Namespace
      stage('[Rest] Enable New App') {
        try {
          eureka.enableApplicationsOnTenantsFlow(namespace.tenants, updatedAppInfoMap)
        } catch (e) {
          logger.warning("Failed to enable (entitle) new application version: ${e}")
          eureka.removeResourcesOnFailFlow(updatedAppInfoMap, module)
          throw e
        }
      }

      stage('[Rest] Remove Stale Resources') {
        eureka.removeStaleResourcesFlow(namespace.applications, updatedAppInfoMap, module)
      }

    } catch (e) {
      logger.warning("Caught exception: ${e}")
      error(e.getMessage())
    } finally {
      stage('Cleanup') {
        logger.debug("Workspace size: ${sh(returnStdout: true, script: 'du -sh .').trim()}")
        cleanWs notFailBuild: true
      }
    }
  }
}
